# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/01_data_types.ipynb (unless otherwise specified).

__all__ = ['ValueType', 'IntType', 'StringType', 'ValueContainer']

# Cell
import typing
from abc import ABCMeta, abstractmethod
import traitlets


class ValueType(object):

    @classmethod
    def create(cls, **data):

        return ValueType(type=data["type"], default=data.get("default", None), required=data.get("required", False), metadata=data.get("metadata", {}))

    def __init__(self, type: str, default: typing.Any=None, required: bool=False, metadata: typing.Mapping[str, typing.Any]=None):

        self._type: str = type
        self._default: typing.Any = default
        self._required: bool = required
        if metadata is None:
            metadata = {}
        else:
            metadata = dict(metadata)
        self._metadata: typing.Dict[str, typing.Any] = metadata
        self._trait: traitlets.TraitType = None
        self._python_type: typing.Type = None

    @property
    def type(self) -> str:
        return self._type

    @property
    def default(self) -> typing.Any:
        return self._default

    @property
    def required(self) -> bool:
        return self._required

    @property
    def metadata(self) -> typing.Mapping[str, typing.Any]:
        return self._metadata

    @property
    def python_type(self) -> typing.Type:
        return self._create_python_type()

    def _create_python_type(self):
        raise NotImplementedError()

    @property
    def trait(self) -> traitlets.TraitType:

        if self._trait is None:
            self._trait = self._create_trait()
        return self._trait

    def _create_trait(self) -> traitlets.TraitType:
        raise NotImplementedError()





class IntType(ValueType):

    _type_id = "int"

    def _create_python_type(self):
        return int

    def _create_trait(self) -> traitlets.TraitType:

        return traitlets.Int()

class StringType(ValueType):

    _type_id = "str"

    def _create_python_type(self):
        return str

    def _create_trait(self) -> traitlets.TraitType:

        return traitlets.Unicode()



class ValueContainer(object):

    def __init__(self, name: str, values: typing.Mapping[str, typing.Mapping[str, typing.Any]]):

        self._name: str = name
        self._value_items: typing.Dict[str, ValueType] = {}
        for name, details in values.items():
            self._value_items[name] = ValueType.create(**details)

        self._hastraits_cls: typing.Type = None

    @property
    def hastraits_cls(self) -> typing.Type:

        if self._hastraits_cls is None:

            traits = {}

            for name, value in self._value_items.items():
                trait_obj = value.create_trait()
                traits[name] = trait_obj

            self._hastraits_cls = type(self._name, (), traits)

        return self._hastraits_obj


